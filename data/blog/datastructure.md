---
slug: data-structure
title: Data Structure
date: 10/6/2022
tags: ['data structure', 'algorithm', 'trie']
lastmod: 10/6/2022
draft: false
summary: Data Structure
authors: ['jerry']
canonicalUrl: ideafresh.me/blog/datastructure
---

English စာလုံးတွေရှိတဲ့ file တစ်ခုထဲကနေ လိုချင်တဲ့ စာလုံး ရှိလားလို့ စစ်ကြည့်ချင်တယ်ဆိုပါစို့
ရှိသမျှ စာလုံးတွေအကုန်လုံးတစ်ကြောင်းချင်းစီ လိုက်စစ်သွားမယ်
file အဆုံးမှာ လိုချင်တဲ့ စာလုံးကိုတွေ့တာရှိမယ် မတွေ့တာရှိမယ်
အဆုံးထိရောက်တာတောင်မတွေ့သေဘူးဆိုရင်တော့ ဒီfile ထဲမှာမရှိဘူးပေါ့
နောက်လိုချင်တဲ့ တစ်လုံးရှိလာရင်လည်း ခုနကလိုပဲ အစကနေအဆုံးထိမတွေ့မချင်း ထပ်ရှာရမယ်
ဒီလို scenario မှာ ရှာချင်တဲ့စာလုံးကို အစကနေအဆုံးဖတ်ပြီးမှ ရှာရမှာမလို့ worst case မှာ O(n) အထိရှိမယ်
`" The lazy fox jump to the tree and ate the apple" `မှာ `"apple"` ဆိုတဲ့ စာလုံးပါလားလို့စစ်ကြည့်ချင်တယ်
အေးဆေးပါ string ကို ယူ space နဲ့ split လုပ်ပြီး တစ်လုံးချင်း လိုက်စစ်ရုံပဲ
split မလုပ်ဘဲ တစ်ခြားနည်းနဲ့ရှာမယ်ဆိုလည်းရတယ်
ဘာပဲပြောပြော worst case မှာ O(n) သွားမှာပဲ
ဒါပေမဲ့ string က ခုလိုတိုတိုလေးမဟုတ်ပဲ စာလုံးပေါင်း သောင်းသိန်းချီ ရှိတဲ့ string ကြီးဆို split လုပ်တာက တစ်ခါ ပြန်ရှာတာကတစ်ခါဆို time complexity နှေးလာမယ် မတွေ့ရင် string အဆုံးထိသွားရမယ်

ဒါပေမဲ့ခုနကသန်းချည်တဲ့စာလုံး တွေကို အောက်က format တစ်ခုနဲ့သိမ်းကြည့်မယ်ဆိုရင်ကော? ခုကstring က

![Trie](/static/images/triet.png)

လိုမျိုးဖြစ်နေတယ်ဆိုပါစို့
တုတ်ချောင်းတွေက အပေါ်က Character နဲ့ အောက်က character ကို ချိတ်ပေးထားတယ်လို့ မှတ်ထားပေးပါ
အဲ့ထဲကနေပြီးတော့ apple ဆိုတာပါလား စစ်ကြည့်မယ်
ပထမဆုံး \* ကနေစမယ် သူနဲ့ချိတ်ပေးထားတာတွေထဲမှာ a ဆိုတာပါလားကြည့်မယ်  
ကနေချိတ်ပေးထားတာက
T t l f j a
a ပါတယ်ပေါ့ ဆိုတော့ a နဲ့ချိတ်ပေးတာတွေကို ဆက်စစ်ကြည့်မယ်
t နဲ့ p
apple ရဲ့ ဒုတိယ character ကလည်း p ဆိုတော့ အဆင်ပြေတယ် ဆက်ဆင်းမယ် p နဲ့ချိတ်ထားတာတွေက p တစ်ခုပဲ သူကလည်း လိုချင်တဲ့ word ရဲ့ တတိယနဲ့ကိုက်သေးတယ် ဆက်ဆင်းမယ် အဲ့လိုပေါ့
နောက်ဆုံးကျတော့ လိုချင်တဲ့စာလုံးရဲ့အဆုံးကိုရောက်သွားပြီ
အဲ့ချိန်မှာ ခုနကနောက်ဆုံးဆင်း ထားတာတာနဲ့ချိတ်ထားတာမှာ စာလုံးတစ်ခုလို့ သတ်မှတ်ထားတဲ့ ! ကိုတွေ့ရတယ် အဲ့လိုမျိုးဆို ဒီစာလုံးပါတယ်ပေါ့
နောက်တစ်ခေါက် အဲ့ထဲမှာ "tree" ဆိုတာရှာချင်တယ်ဆိုပါစို့
အပေါ်ဆုံးကိုပြန်သွား သူ့မှာ t ပါလား ပါရင်ဆင်းမယ် ခုနကအတိုင်းပဲ အဲ့လိုဆက်လုပ်သွားမယ်ဆိုရင် tree က string ထဲမှပါတယ်ပေါ့
နောက်အဲ့ထဲကမှ "fo" ဆိုတာပါလား စစိကြည့်မယ်
f ပါတယ် o လည်းပါတယ် ဒါပေမဲ့ o ကနေပြီးတော့ word တစ်ခုလို့ အဓိပ္ပာယ်ရတဲ့ ! တဲ့ character မပါဘူး အာ့ဆို fo ဆိုတဲ့ စာလုံး ဒီ String ထဲမှာမရှိဘူးလို့ပြောလို့ရတယ်ပေါ့
လုံးဝမပါတဲ့ စာလုံးဆိုလည်း ပထမအဆင့်မှာတဲ့ရပ်ပြီး program ကနေမပါကြောင်းထုတ်လို့ရမယ်
ဥပမာ "dog" ဆိုတာရှာချင်ရင် ပထမမှာတင် d ကမပါလို့ ရပ်လိုက်ရုံပဲ

ဒီလို Format နဲ့သိမ်းထားတဲ့ data ထဲမှာ လိုချင်တာရှာဖို့ဆို Time Complexity ဘယ်လောက်ရှိမလဲ?
လိုချင်တဲ့စာလုံးရှိတယ်ဆိုပါစို့
အပေါ် character ကနေ အောက် character ကိုတစ်ခါဆင်းတိုင်း အပေါ် character နဲ့ချိတ်ထားတဲ့ character ကတွေအကုန်လုံးကို လိုက်စစ်ကြည့်ရမယ်
အဲ့လိုမျိုးလိုက်စစ်တာက သတ်မှတ်ထားတဲ့ စာလုံးပေါ်မူတည်တယ်
word တွေအကုန်လုံးက A-Z နဲ့ a-z ထိပဲရှိတဲ့ string မျိုးဆို
26+26=52
52 ကြိမ်အများဆုံး စစ်ရနိုင်တယ်
လိုချင်တဲ့ string lengthက 6 ဆို total operation ပေါင်း
52 * 6
အဲ့တော့ Time Complexity = O(52*k) , where k is length of required string
အဲ့တော့ ရိုးရိုးတစ်လုံးချင်းစီ လိုက်စစ်တာထက် ဒီလိုformat နဲ့ သိမ်းထားတဲ့ data တွေက million, billion လောက်ရှိတဲ့ နေရာတွမှာ အပြတ်အသတ်သာသွားမယ်

ဒီ data structure မျိုးကို Trie လို့ခေါ်တယ်

---

data structure ဆိုတာ data တွေကို ပုံစံအမျိုးမျိုး အချိတ်အဆတ်အမျိုးမျိုးနဲ့ ဖွဲ့စည်းထားတဲ့ အစုအဝေးတစ်ခုဖြစ်တယ်(definition)

data structure တွေကို ကိုယ်လိုချင်တဲ့အတိုင်း လိုအပ်သလိုပြောင်းလဲပြီး ဖွဲ့စည်းနိုင်တယ်
ခုနက ဥပမာလိုပဲ စာလုံးတွေ ခဏ ခဏ ရှာရမယ် မြန်လည်းမြန်ချင်တယ်ဆိုရင် ရိုးရိုး string အကြီးထဲကနေ တစ်လုံးချင်းလိုက်စစ်ရမှာထက် Trie လိုကောင်မျိုးသုံးပြီး ရှာတာကပိုမြန်တယ်ပေါ့

သုံးနေကျ english - myanmar dictionary တွေမှာ စာလုံးတွေကို lexically စီပေးထားတော့ ကိုယ်သိချင်တဲ့ စာလုံးပေါ်မူတည်ပြီး လိုက်လှန်ကြည့်ရုံပဲ ပိုမြန်တယ် အဆင်ပြေတယ်
အခု data structure တွေဆိုလည်း အဲ့တိုင်းပဲ

တွဲ့သုံးမဲ့ algorithm တွေပေါ်မူတည်းပြီး data structure အမျိုးမျိုးရှိတယ်ပေါ့
ဥပမာ data က dynamically အဝင်အထွက်များမယ် ဒါပေမဲ့ လိုချင်တာက ရှိထားတဲ့ data တွေထဲက အငယ်ဆုံး သို့ အကြီးဆုံးကိုလိုချင်တာ
ဒါဆိုရင် Linked list ထက် min heap သို့ max heap လိုကောင်မျိုးကို သုံးသင့်တယ်
ဥပမာ 5 , 8 , 7 , 2, 1 ထဲကနေ အငယ်ဆုံးကိုလိုချင်တယ် ဆိုပါစို့
min heap ကိုသုံးရင် ပထမဆုံး တစ်လုံးကို ယူရုံပဲ
constant time O(1) ပေါ့
အဲ့အငယ်ဆုံးတစ်လုံးကို လုံးဝထုတ်ချင်ရင်လည်း Log(n) ပဲကြာမယ်
အဲ့ data တွေထဲ နောက်ထပ် data တွေ ထပ်ထည့်ချင်တာ ဖျက်ပစ်ချင်တာမျိုးဆိုလည်း operation တိုင်းကို log(n) နဲ့လုပ်ပေးနိုင်တယ်
ဒီလိုcase မှာ Linked list လိုကောင်မျိုးသုံးရင် လိုချင်တဲ့ result ရမယ် ဒါပေမဲ့ Complexity ကွါသွားမယ်
ပထမဆုံး nodeတွေထည့်ပြီး sort ရင် O(nlogn)
ဒါက min heap ဆောက်တဲ့ complexity နဲ့တူတယ်
ဒါပေမဲ့ နောက် node တစ်ခုအသစ်ထည့်ချင်တာဆိုရင် ဘယ်နားချိတ်မလဲပြန်ရှာရမှာမလို့ worst case မှာ O(n) ကြာတယ် heap ဆိုရင် log(n) ပဲကြာမှာ
ထုတ်တဲ့ case မှာလည်းပြန်ရှာဖို့ worst case မှာ O(n) ပြန်ကြာမယ်
အဲ့လိုပေါ့ min heap က node အများကြီးမှာ total time
O(nlongn) ပဲကြာမှာပေမဲ့ linked list မှာ O(n^2) ဖြစ်သွားမှာပေါ့
Linked list ကိုဘယ်လိုနေရာတွေသုံးမလဲဆိုရင်
node တွေကို operation လုပ်စရာမလိုဘဲ သိမ်းထားရုံပြရုံပဲဆို
linked list ကိုသုံးသင့်တယ်ပေါ့
node အသစ်ထည့်ရင် O(1)နဲ့ထည့်ပေးနိုင်တယ်
ပြီးရင် Linked list ကို stack တို့ queue တို့သဘောနဲ့သုံးလို့လည်းရသေးတယ်

`Array`

array ကို ဘယ်လိုနေရာတွေသုံးကြလဲဆိုရင် static ဖြစ်တဲ့အချိန်တွေ type တူတဲ့အချိန်တွေမှာသုံးတယ်
အဓိကရည်ရွယ်ချက်က သူ့ကို value တွေ index နဲ့ယူနိုင်ဖို့အတွက်သုံးတာပဲ
Widely used အဖြစ်ဆုံး data structure ဖြစ်တယ်
data structure တော်တော်များများ array ပေါ်မှာဆောက်ထားကြတယ်

ခုနက case ကိုပဲ အငယ်ဆုံးလိုချင်တာမဟုတ်ပဲ တတိယအကြီးဆုံး ကိုလိုချင်တာဆိုပါစို့
min heap နဲ့ဆို ပထမတစ်လုံးကို သုံးခါ pop လုပ်ယူရမယ်
၃ခါဆိုမသိသာပေမဲ့ အလုံးပေါင်းသန်းချီထဲက 1000 ကြိမ်မြောက် ကိုလိုချင်တာဆိုရင် min heap မှာ အခါပေါင်း 1000 operation လုပ်ရမယ် operation တိုင်းသည် O(logn) ကြာမယ်
ဒါပေမဲ့ array ကိုသုံးရင် index 999 ကို memory address တွက်ပြီး O(1) constant time နဲ့ access လုပ်ရုံပဲ
အဲ့လိုမျိုးတွေပေါ့ လိုချင်တဲ့ result ပေါ်မူတည်ပြီး သူနဲ့သင့်လျော်မဲ့ data structure ကိုသုံးပေးရမယ်

Data Structure တွေကိုအမျိုးအစားခွဲရင်
`Linear Data Structure` နဲ့
`Non-Linear Data Structure` ဆိုပြီးရှိတယ်
Linear မှာကြတော့ array , stack , queue , linked list တို့ပါတယ် သူတို့တွေရဲ့ ချိတ်ဆက်ပုံက level တစ်ခုထဲမှာပဲ
Non linear ​တွေဖြစ်တဲ့ tree တို့ graph တွေမှာ data အချင်းချင်းချိတ်ဆက်ပုံက level တွေနဲ့

ဥပမာ linked list မှာဆိုရင် ပထမဆုံး item ရှိမယ် အဲ့ တစ်ခုနဲ့ ချိတ်ထားတဲ့ နောက် item တစ်ခုရှိမယ် အဲ့ item နဲ့ပြန်ချိတ်ထားတဲ့ နောက်တစ်ခုရှိမယ် အဲ့လိုပေါ့
tree မှာဆိုရင် parent node ရှိမယ် သူ့ရဲ့ children တွေရှိမယ် အဲ့ children တွေကို parent အဖြစ်ချိတ်ထားတဲ့ နောက်children တွေရှိမယ် level အလိုက်တွေပေါ့
ရူတ်သွားပြီလားမသိဘူး😁

Linked List

++++++++++

```java:Node.java
class Node
{

Node next;

//constructor ......

}

```

Binary Tree

++++++++++

```java:Node.java
class Node{

Node leftChild,Node rightChild;

//constructor  .......

insert()
delete()
:
:
}
```

Linked list မှာကြတော့ peer အလိုက်ချိတ်ထားပြီးတော့ Binary Tree မှာကြတော့ level အလိုက် parent children နဲ့ချိတ်ထားတယ်ပေါ့

Data structures and Primitive Data Type

သူတို့နှစ်ခုက မတူပါဘူး static programming language တွေမှာ default အနေနဲ့ primitive data type တွေပါတယ်
ဥပမာ - int , float , char , byte
သူတို့တွေက default ပါပြီး သက်ဆိုင်ရာ language ကနေပြီးတော့ memory ပေါ်တစ်ခါထဲနေရာယူပေးတယ်
java က class ကိုအခြေခံတယ်
အဲ့ကြတော့ data structuresတွေကို class ပေါ်မှာဆောက်ကြတယ်
အပေါ်က class Node မှာ next အတွက် Node အမျိုးအစားတစ်ခုရှိတယ်
class ကနေပဲ node တစ်ခုနဲ့ တစ်ခု ချိတ်ပေးသွားတာ
ပြီးရင် သူနဲ့သက်ဆိုင်တဲ့ method တွေရှိမယ်ပေါ့

data structure တွေကို သူတို့အချင်းချင်းခေါ်သုံးတာတွေ
algorithm တွေကနေခေါ်သုံးတာတွေရှိတယ်
ဥပမာ Hashtable ဆိုရင် array ကို အဓိကခေါ်သုံးပြီးဆောက်တယ်
နောက် Dijkstras' algorithm မှာဆိုလည်း shortest node တွေ သိမ်းဖို့ min heap ကိုသုံးတယ်
Data structure တွေဆိုတာ Design Pattern လိုပဲ
"exact code" မဟုတ်ပဲ ဘယ်လိုလုပ်ရမယ်ဆိုတဲ့ ဘယ်လိုတည်ဆောက်ရမယ်ဆိုတဲ့ rule သက်သက်ပဲ
heap ကို array မသုံးဘဲ tree structure နဲ့လည်းရေးလို့ရသလိုပေါ့

Check here

[Heap with Tree](https://www.cpp.edu/~ftang/courses/CS241/notes/Building_Heaps_With_Pointers.pdf)
